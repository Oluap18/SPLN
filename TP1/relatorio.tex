\documentclass{report}

\usepackage[latin1]{inputenc}
\usepackage[portuguese]{babel}
\usepackage{graphicx}


\parindent=0pt
\parskip=2pt

\setlength{\oddsidemargin}{-1cm}
\setlength{\textwidth}{18cm}
\setlength{\headsep}{-1cm}
\setlength{\textheight}{23cm}

\title{Scripting no Processamento de Linguagens Naturais\\ (4∫ ano de Curso de MiEI)\\ \textbf{Trabalho Pr·tico 1}\\ RelatÛrio de Desenvolvimento}
\author{Catarina Cardoso\\ (a75037) \and Paulo Guedes\\ (a74411) \and Pedro Cunha\\ (a73958)}
\date{03/11/2017}

\begin{document}

\maketitle

\tableofcontents

\chapter{IntroduÁ„o} \label{intro}

\section*{DescriÁ„o} \
No ‚mbito da unidade curricular de Scripting no Processamento de Linguagens Naturais, foi proposta a resoluÁ„o de um trabalho pr·tico usando a linguagem Perl que identificasse os nomes prÛprios presentes num texto e os relacionasse entre si, originando assim uma tabela de relacionamentos. Nesta tabela que relaciona È possÌvel observar o n˙mero de vezes que os nomes se encontram na vizinhanÁa um do outro e, assim, concluir qual o grau de "simpatia" entre eles.

\section*{Estrutura do RelatÛrio} \
ApÛs o capÌtulo introdutÛrio, segue-se o capÌtulo~\ref{di} onde se expıe detalhamente as decisıes de implementaÁ„o tomadas aquando a realizaÁ„o do projeto. No final, no apÍndice, pode-se encontrar o ficheiro usado na realizaÁ„o do trabalho pr·tico.

\chapter{Decisıes e ImplementaÁ„o} \label{di}
Para que o programa fosse capaz de detetar e relacionar os nomes prÛprios entre si foi utilizada uma express„o regular que fosse capaz de reconhecer um padr„o que incluÌsse, pelo menos, dois nomes prÛprios. 
Esta express„o regular identifica a maior correspondÍncia encontrada e, de forma iterativa, percorre todos os par·grafos do texto, associando a cada nome prÛprio todos os nomes prÛprios que o precedem.
Caso sejam encontrados mais de dois nomes na correspondÍncia feita anteriormente, s„o identificados os seguintes nomes, utilizando o menor match e iterando nome a nome.\\
De seguida, os nomes s„o inseridos numa tabela de Hash, em que a key est· no formato "NomeProprio1-NomeProprio2" e o value corresponde ao n˙mero de vezes que, ao longo do texto, È encontrada essa relaÁ„o.
Caso esta relaÁ„o seja detetada mais que uma vez num par·grafo, o contador È incrementado apenas uma vez.\\
Para evitar que haja dois contadores distintos para um par de nomes prÛprios È verificada a existÍncia desse par ordenado das duas possÌveis formas.
Por exemplo, quando È encontrada uma relaÁ„o entre os nomes "X" e "Y" procura-se pela chave "X-Y" na tabela de Hash.
Caso n„o seja encontrada essa key, e antes de ser inserida essa nova entrada na tabela, È feita uma procura pela chave "Y-X".\\
ApÛs o tratamento do texto e do preenchimento da tabela de Hash, os nomes prÛprios nela inseridos s„o filtrados e separados atravÈs de expressıes regulares, de modo a serem inseridos no grafo (figura~\ref{fig1}) que representa todas as ligaÁıes encontradas.

\begin{figure}[h!]
  \includegraphics[width=\linewidth]{grafo.png}
  \caption{Grafo de relacionamentos}
  \label{fig1}
\end{figure}


\appendix

\chapter{CÛdigo do Programa}
\begin{verbatim}
#!/usr/bin/perl

use Graph::Easy;
use strict;
use warnings;
use utf8::all;

my $graph = Graph::Easy->new();
my $i=25;
my %sortedHash;
my $union;
my $pessoa;
my $fPers;
my $uPers;
my $resto;

my $PM = qr{[A-Z¡¿√… ⁄Õ”«][a-z·‡„ÈÍ˙ÌÛÁ]+};
my $de = qr{d[aoe]s?};
my $s = qr{[\n ]};
my $Pre = qr{Sr\. |Sra\. |Dr\. |Dra\. |Eng\. |Miss\. |Mr\. };
my $np = qr{$Pre? $PM ($s $PM|$s $de $s $PM)*}x;
my $pal = qr{[\w·‡„ÈÍ˙ÌÛÁ]+};
my $all = qr{.*};
my $allP = qr{.*?};

while(<>){

    s/(^|[\n]|[?!.;:]|['"´]|[-]|^--)( ?)($PM)/$1$2_$3/g;
    s/($Pre)(_)($np)/_$1_$3/g;
    s/(\b$np)/{$1}/g;
    s/(_)($Pre)(_)($np)/{$2$4}/g;

    while(/{($np)}($all){($np)}/g){
        my %pessoas;
        $fPers = $1;
        $uPers = $4;
        $resto = $3;
        $pessoas{$fPers}++;

        if($resto =~ /{($np)}/) {
            while($resto =~ /($allP) \{($np)\}($all)/){
                $pessoa = $2;
                if(!exists $pessoas{$pessoa}){
                    foreach my $key (keys %pessoas){
                        verifica($key, $pessoa);
                    }
                    $pessoas{$pessoa}++; 
                }
                $resto = $4;
            }
            if(!exists $pessoas{$uPers}){
                foreach my $key (keys %pessoas){
                    verifica($key, $uPers);
                }
            }
        }

        else{
            verifica($fPers, $uPers);
        }
    }
    s/{($np)}/$1/g;
    s/_//g;
}

for (sort{$sortedHash{$b} <=> $sortedHash{$a}} keys %sortedHash){
    if(/($np)-($np)/g) {
        $union = "$1-$3";
        if ($1 !~ /$3/ && $3 !~ /$1/) {
            $graph->add_edge ($1, $3);
        }
    }
    $i--;
    if ($i eq 0) {last;}
}

print $graph->as_html_file( );

sub verifica {
    my $tempV;
    my $tempV2;
    my ($p1, $p2) = @_;
    $tempV = "$p2-$p1";
    $tempV2 = "$p1-$p2";
    if ($sortedHash{$tempV}) {
        $sortedHash{$tempV}++;
    }
    else {
        $sortedHash{$tempV2}++;
    }
}
\end{verbatim}

\end{document} 